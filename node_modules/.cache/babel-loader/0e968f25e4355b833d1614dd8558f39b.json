{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __require = typeof require !== \"undefined\" ? require : x => {\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n}; // src/components/MatchContext.tsx\n\n\nimport React, { useReducer, useCallback, createContext, useEffect, useMemo } from \"react\"; // src/components/Types.d.ts\n\nvar IActionTypes;\n\n(function (IActionTypes2) {\n  IActionTypes2[\"setSearchValue\"] = \"setSearchValue\";\n  IActionTypes2[\"setActiveMatch\"] = \"setActiveMatch\";\n  IActionTypes2[\"setMatchList\"] = \"setMatchList\";\n})(IActionTypes || (IActionTypes = {})); // src/components/MatchContext.tsx\n\n\nvar scrollToView = function (id) {\n  let fixHeaderHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const dom = document.getElementById(id);\n\n  if (dom) {\n    const topOfElement = dom.getBoundingClientRect().bottom + window.pageYOffset - fixHeaderHeight;\n    window.scroll({\n      top: topOfElement,\n      behavior: \"smooth\"\n    });\n  }\n};\n\nvar defaultStore = {\n  searchValue: \"\",\n  totalCount: 0,\n  activeCount: 0,\n  activeId: \"\",\n  matchedList: []\n};\nvar searchEventStore = {\n  onSearchChange: () => {},\n  onPrev: () => {},\n  onNext: () => {},\n  onUpdateMatchList: () => {}\n};\n\nvar reducer = (state, action) => {\n  if (action.type === IActionTypes.setSearchValue) {\n    return __spreadProps(__spreadValues({}, state), {\n      searchValue: action.payload.searchValue\n    });\n  }\n\n  if (action.type === IActionTypes.setActiveMatch) {\n    return __spreadProps(__spreadValues({}, state), {\n      activeId: action.payload.activeId,\n      activeCount: action.payload.activeCount\n    });\n  }\n\n  if (action.type === IActionTypes.setMatchList) {\n    return __spreadProps(__spreadValues({}, state), {\n      matchedList: action.payload\n    });\n  }\n\n  return state;\n};\n\nvar SearchContext = createContext(defaultStore);\nvar SearchEventContext = createContext(searchEventStore);\n\nvar SearchProvider = props => {\n  var _a, _b;\n\n  const [store, dispatch] = useReducer(reducer, defaultStore);\n  const activeCount = store.activeCount;\n  const totalCount = (_a = store.matchedList) == null ? void 0 : _a.length;\n  const onSearchChange = useCallback(e => {\n    const searchValue = e.target.value;\n    dispatch({\n      type: IActionTypes.setSearchValue,\n      payload: {\n        searchValue\n      }\n    });\n  }, []);\n  const onPrev = useCallback(fixedHeaderHeight => {\n    var _a2, _b2, _c;\n\n    if (activeCount > 0) {\n      let prevActiveCount = activeCount - 1 < 1 ? store.matchedList.length : activeCount - 1;\n      let matchIndex = prevActiveCount - 1;\n      let prevActiveId = store.matchedList[matchIndex].id;\n      dispatch({\n        type: IActionTypes.setActiveMatch,\n        payload: {\n          activeId: prevActiveId,\n          activeCount: prevActiveCount\n        }\n      });\n\n      if (typeof fixedHeaderHeight !== \"number\") {\n        fixedHeaderHeight = (_a2 = props.value) == null ? void 0 : _a2.fixedHeaderHeight;\n      }\n\n      if (typeof ((_b2 = props.value) == null ? void 0 : _b2.onScroll) === \"function\") {\n        (_c = props.value) == null ? void 0 : _c.onScroll(prevActiveId, fixedHeaderHeight);\n      } else {\n        scrollToView(prevActiveId, fixedHeaderHeight);\n      }\n    }\n  }, [activeCount, totalCount]);\n  const onNext = useCallback(fixedHeaderHeight => {\n    var _a2, _b2, _c;\n\n    if (activeCount > 0) {\n      let nextActiveCount = activeCount + 1 > store.matchedList.length ? 1 : activeCount + 1;\n      let matchIndex = nextActiveCount - 1;\n      let nextActiveId = store.matchedList[matchIndex].id;\n      dispatch({\n        type: IActionTypes.setActiveMatch,\n        payload: {\n          activeId: nextActiveId,\n          activeCount: nextActiveCount\n        }\n      });\n\n      if (typeof fixedHeaderHeight !== \"number\") {\n        fixedHeaderHeight = (_a2 = props.value) == null ? void 0 : _a2.fixedHeaderHeight;\n      }\n\n      if (typeof ((_b2 = props.value) == null ? void 0 : _b2.onScroll) === \"function\") {\n        (_c = props.value) == null ? void 0 : _c.onScroll(nextActiveId, fixedHeaderHeight);\n      } else {\n        scrollToView(nextActiveId, fixedHeaderHeight);\n      }\n    }\n  }, [activeCount, totalCount]);\n  const onUpdateMatchList = useMemo(function () {\n    let cacheList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return function () {\n      let matchList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      cacheList = cacheList.concat(matchList);\n      dispatch({\n        type: IActionTypes.setMatchList,\n        payload: cacheList\n      });\n    };\n  }, [store.searchValue]);\n  useEffect(() => {\n    if (store.matchedList.length > 0) {\n      dispatch({\n        type: IActionTypes.setActiveMatch,\n        payload: {\n          activeId: store.matchedList[0].id,\n          activeCount: 1\n        }\n      });\n    }\n  }, [store.matchedList]);\n  return /* @__PURE__ */React.createElement(SearchContext.Provider, {\n    value: __spreadProps(__spreadValues({}, store), {\n      totalCount,\n      ignorecase: (_b = props.value) == null ? void 0 : _b.ignorecase\n    })\n  }, /* @__PURE__ */React.createElement(SearchEventContext.Provider, {\n    value: {\n      onSearchChange,\n      onUpdateMatchList,\n      onPrev,\n      onNext\n    }\n  }, props.children));\n}; // src/components/MatchText.tsx\n\n\nimport React2, { useContext, useMemo as useMemo2, useLayoutEffect } from \"react\";\nvar MARK = \"__$CTRL_F$__\";\n\nfunction escapeStr(str) {\n  return \"\".concat(str).replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n}\n\nfunction getMatchId(prefixId, index) {\n  return \"\".concat(prefixId, \"_\").concat(index);\n}\n\nfunction getMatchText(keyword, text) {\n  let ignorecase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let keywordStr = keyword;\n  let textStr = text;\n\n  if (typeof keyword === \"number\") {\n    keywordStr = \"\".concat(keyword);\n  }\n\n  if (typeof text === \"number\") {\n    textStr = \"\".concat(text);\n  }\n\n  if (typeof keywordStr !== \"string\" || !keywordStr.trim() || typeof textStr !== \"string\" || !textStr.trim() || !textStr.toLowerCase().includes(keywordStr.toLowerCase())) {\n    return text;\n  }\n\n  const regexp = new RegExp(escapeStr(keywordStr), ignorecase ? \"gi\" : \"g\");\n  const matches = [];\n  const textWithMark = textStr.replace(regexp, match => {\n    matches.push(match);\n    return MARK;\n  });\n  const slices = textWithMark.split(MARK);\n  const data = {\n    slices,\n    matches\n  };\n  return data;\n}\n\nvar MatchText = data => {\n  let textStr = data.text;\n  const id = data.id;\n\n  if (typeof data.children === \"string\") {\n    textStr = data.children;\n  }\n\n  if (!textStr) {\n    return /* @__PURE__ */React2.createElement(React2.Fragment, null, textStr);\n  }\n\n  let {\n    searchValue,\n    activeId,\n    ignorecase\n  } = useContext(SearchContext);\n  const {\n    onUpdateMatchList\n  } = useContext(SearchEventContext);\n  ignorecase = typeof data.ignorecase === \"boolean\" ? data.ignorecase : ignorecase;\n  const matchData = useMemo2(() => getMatchText(searchValue, textStr, ignorecase), [searchValue]);\n  useLayoutEffect(() => {\n    if (typeof matchData === \"object\") {\n      const matchIds = matchData.matches.map((_, index) => ({\n        id: getMatchId(id, index),\n        idCount: index\n      }));\n      onUpdateMatchList(matchIds);\n    }\n  }, [matchData]);\n\n  if (typeof matchData === \"string\") {\n    return /* @__PURE__ */React2.createElement(React2.Fragment, null, matchData);\n  }\n\n  const slicesLen = matchData.slices.length - 1;\n  return /* @__PURE__ */React2.createElement(React2.Fragment, null, matchData.slices.map((slice, index) => {\n    if (index === slicesLen) {\n      return slice;\n    }\n\n    const matchId = getMatchId(id, index);\n    const color = matchId === activeId ? \"#ff9632\" : \"#ffff00\";\n    const matchStr = matchData.matches[index];\n    return /* @__PURE__ */React2.createElement(React2.Fragment, {\n      key: index\n    }, slice, /* @__PURE__ */React2.createElement(\"span\", {\n      id: matchId,\n      style: {\n        backgroundColor: color,\n        display: \"inline-block\",\n        whiteSpace: \"pre-wrap\"\n      }\n    }, matchStr));\n  }));\n};\n\nexport { MatchText, SearchContext, SearchEventContext, SearchProvider };","map":{"version":3,"sources":["../../src/components/MatchContext.tsx","../../src/components/Types.d.ts","../../src/components/MatchText.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, {\n  useReducer,\n  useCallback,\n  createContext,\n  useEffect,\n  useMemo,\n} from 'react';\n\nimport {\n  EventContextProps,\n  MatchObjectProps,\n  IState,\n  IActions,\n  IActionTypes,\n  SearchProviderProps,\n} from './Types.d';\n\nconst scrollToView = (id: string, fixHeaderHeight: number = 0) => {\n  const dom = document.getElementById(id);\n  if (dom) {\n    const topOfElement =\n      dom.getBoundingClientRect().bottom + window.pageYOffset - fixHeaderHeight;\n    window.scroll({\n      top: topOfElement,\n      behavior: 'smooth',\n    });\n  }\n};\n\nconst defaultStore: IState = {\n  searchValue: '',\n  totalCount: 0,\n\n  activeCount: 0, // actived count, less than or equal totalCount\n  activeId: '', // active text id\n  matchedList: [],\n};\n\nconst searchEventStore: EventContextProps = {\n  onSearchChange: () => {},\n  onPrev: () => {},\n  onNext: () => {},\n  onUpdateMatchList: () => {},\n};\n\nconst reducer = (state: IState, action: IActions): IState => {\n  if (action.type === IActionTypes.setSearchValue) {\n    return {\n      ...state,\n      searchValue: action.payload.searchValue,\n    };\n  }\n\n  if (action.type === IActionTypes.setActiveMatch) {\n    return {\n      ...state,\n      activeId: action.payload.activeId,\n      activeCount: action.payload.activeCount,\n    };\n  }\n  if (action.type === IActionTypes.setMatchList) {\n    return {\n      ...state,\n      matchedList: action.payload,\n    };\n  }\n  return state;\n};\n\nexport const SearchContext = createContext(defaultStore);\nexport const SearchEventContext = createContext(searchEventStore);\n\nexport const SearchProvider = (props: SearchProviderProps) => {\n  const [store, dispatch] = useReducer(reducer, defaultStore);\n\n  const activeCount = store.activeCount;\n  const totalCount = store.matchedList?.length;\n  const onSearchChange = useCallback((e) => {\n    const searchValue = e.target.value;\n    dispatch({ type: IActionTypes.setSearchValue, payload: { searchValue } });\n  }, []);\n\n  // Calculate previous match text\n  const onPrev = useCallback(\n    (fixedHeaderHeight) => {\n      if (activeCount > 0) {\n        let prevActiveCount =\n          activeCount - 1 < 1 ? store.matchedList.length : activeCount - 1;\n        let matchIndex = prevActiveCount - 1;\n        let prevActiveId = store.matchedList[matchIndex].id;\n        dispatch({\n          type: IActionTypes.setActiveMatch,\n          payload: { activeId: prevActiveId, activeCount: prevActiveCount },\n        });\n\n        // scroll To View\n        if (typeof fixedHeaderHeight !== 'number') {\n          fixedHeaderHeight = props.value?.fixedHeaderHeight;\n        }\n        if (typeof props.value?.onScroll === 'function') {\n          props.value?.onScroll(prevActiveId, fixedHeaderHeight);\n        } else {\n          scrollToView(prevActiveId, fixedHeaderHeight);\n        }\n      }\n    },\n    [activeCount, totalCount]\n  );\n\n  // Calculate next match text\n  const onNext = useCallback(\n    (fixedHeaderHeight) => {\n      if (activeCount > 0) {\n        // update active count\n        let nextActiveCount =\n          activeCount + 1 > store.matchedList.length ? 1 : activeCount + 1;\n        let matchIndex = nextActiveCount - 1;\n        let nextActiveId = store.matchedList[matchIndex].id;\n        dispatch({\n          type: IActionTypes.setActiveMatch,\n          payload: { activeId: nextActiveId, activeCount: nextActiveCount },\n        });\n\n        // scroll To View\n        if (typeof fixedHeaderHeight !== 'number') {\n          fixedHeaderHeight = props.value?.fixedHeaderHeight;\n        }\n        if (typeof props.value?.onScroll === 'function') {\n          props.value?.onScroll(nextActiveId, fixedHeaderHeight);\n        } else {\n          scrollToView(nextActiveId, fixedHeaderHeight);\n        }\n      }\n    },\n    [activeCount, totalCount]\n  );\n\n  const onUpdateMatchList = useMemo(\n    (cacheList: MatchObjectProps[] = []) =>\n      (matchList: MatchObjectProps[] = []) => {\n        // cache initialList\n        cacheList = cacheList.concat(matchList);\n        dispatch({ type: IActionTypes.setMatchList, payload: cacheList });\n      },\n    [store.searchValue]\n  );\n\n  useEffect(() => {\n    // After calculating all match components, calculate totalCount and activeCount\n    if (store.matchedList.length > 0) {\n      dispatch({\n        type: IActionTypes.setActiveMatch,\n        payload: {\n          activeId: store.matchedList[0].id,\n          activeCount: 1,\n        },\n      });\n    }\n  }, [store.matchedList]);\n\n  return (\n    <SearchContext.Provider\n      value={{\n        ...store,\n        totalCount,\n        ignorecase: props.value?.ignorecase,\n      }}\n    >\n      <SearchEventContext.Provider\n        value={{\n          onSearchChange,\n          onUpdateMatchList,\n          onPrev,\n          onNext,\n        }}\n      >\n        {props.children}\n      </SearchEventContext.Provider>\n    </SearchContext.Provider>\n  );\n};\n","import React from 'react';\n\nexport enum IActionTypes {\n  setSearchValue = 'setSearchValue',\n  setActiveMatch = 'setActiveMatch',\n  setMatchList = 'setMatchList',\n}\n\nexport interface MatchObjectProps {\n  id: string;\n  idCount: number;\n}\n\nexport interface IState {\n  searchValue: string;\n  totalCount: number;\n  activeCount: number;\n  activeId: string;\n  matchedList: MatchObjectProps[];\n  ignorecase?: boolean;\n}\n\nexport interface EventContextProps {\n  onSearchChange: (\n    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n  ) => void;\n  onNext: (data: any) => void;\n  onPrev: (data: any) => void;\n  onUpdateMatchList: (matchedList: MatchObjectProps[]) => void;\n}\n\nexport interface IAction1 {\n  type: IActionTypes.setSearchValue;\n  payload: {\n    searchValue: string;\n  };\n}\n\nexport interface IAction2 {\n  type: IActionTypes.setActiveMatch;\n  payload: {\n    activeId: string;\n    activeCount: number;\n  };\n}\n\nexport interface IAction3 {\n  type: IActionTypes.setMatchList;\n  payload: MatchObjectProps[];\n}\nexport type IActions = IAction1 | IAction2 | IAction3;\n\nexport interface MatchTextProps {\n  id: string;\n  text?: string;\n  children?: React.ReactChild;\n  ignorecase?: boolean;\n}\n\nexport interface SearchProviderProps {\n  children: React.ReactNode;\n  value?: {\n    fixedHeaderHeight?: number;\n    onScroll?: (id: string, fixedHeight?: number) => void;\n    ignorecase?: boolean;\n  };\n}\n","import React, { useContext, useMemo, useLayoutEffect } from 'react';\n\nimport { SearchContext, SearchEventContext } from './MatchContext';\nimport { MatchTextProps } from './Types';\n\nconst MARK = '__$CTRL_F$__';\n\nfunction escapeStr(str: string) {\n  return `${str}`.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n}\n\nfunction getMatchId(prefixId: string, index: number) {\n  return `${prefixId}_${index}`;\n}\n\nfunction getMatchText(\n  keyword: string,\n  text: string,\n  ignorecase: boolean = true\n) {\n  let keywordStr = keyword;\n  let textStr = text;\n  if (typeof keyword === 'number') {\n    keywordStr = `${keyword}`;\n  }\n  if (typeof text === 'number') {\n    textStr = `${text}`;\n  }\n  if (\n    typeof keywordStr !== 'string' ||\n    !keywordStr.trim() ||\n    typeof textStr !== 'string' ||\n    !textStr.trim() ||\n    !textStr.toLowerCase().includes(keywordStr.toLowerCase()) // case insensitive\n  ) {\n    return text;\n  }\n  const regexp = new RegExp(escapeStr(keywordStr), ignorecase ? 'gi' : 'g');\n  const matches: string[] = []; // save matched string, we will use this to overwrite keywordStr in the result string\n  const textWithMark = textStr.replace(regexp, (match) => {\n    matches.push(match);\n    return MARK;\n  });\n  const slices = textWithMark.split(MARK);\n  const data = {\n    slices,\n    matches,\n  };\n  return data;\n}\n\nexport const MatchText = (data: MatchTextProps): React.ReactElement<string> => {\n  let textStr = data.text!;\n  const id = data.id;\n  if (typeof data.children === 'string') {\n    textStr = data.children;\n  }\n  if (!textStr) {\n    return <>{textStr}</>;\n  }\n\n  let { searchValue, activeId, ignorecase } = useContext(SearchContext);\n  const { onUpdateMatchList } = useContext(SearchEventContext);\n  ignorecase =\n    typeof data.ignorecase === 'boolean' ? data.ignorecase : ignorecase;\n\n  const matchData = useMemo(\n    () => getMatchText(searchValue, textStr, ignorecase),\n    [searchValue]\n  );\n\n  useLayoutEffect(() => {\n    if (typeof matchData === 'object') {\n      const matchIds = matchData.matches.map((_, index) => ({\n        id: getMatchId(id, index),\n        idCount: index,\n      }));\n      onUpdateMatchList(matchIds);\n    }\n  }, [matchData]);\n\n  if (typeof matchData === 'string') {\n    return <>{matchData}</>;\n  }\n  const slicesLen = matchData.slices.length - 1;\n  return (\n    <React.Fragment>\n      {matchData.slices.map((slice, index) => {\n        if (index === slicesLen) {\n          return slice;\n        }\n        const matchId = getMatchId(id, index);\n        const color = matchId === activeId ? '#ff9632' : '#ffff00';\n        const matchStr = matchData.matches[index];\n        return (\n          <React.Fragment key={index}>\n            {slice}\n            <span\n              id={matchId}\n              style={{\n                backgroundColor: color,\n                display: 'inline-block',\n                whiteSpace: 'pre-wrap',\n              }}\n            >\n              {matchStr}\n            </span>\n          </React.Fragment>\n        );\n      })}\n    </React.Fragment>\n  );\n};\n\nexport default MatchText;\n"]},"metadata":{},"sourceType":"module"}